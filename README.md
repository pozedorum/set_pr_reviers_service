# Сервис Назначения Ревьюеров для Pull Request'ов

Микросервис для автоматического назначения ревьюеров на Pull Request'ы и управления командами разработчиков.

## Быстрый старт

### 1. Настройка окружения

Создайте файл `.env` на основе примера:

```bash
cp .env.example .env
```

Отредактируйте `.env` при необходимости:
```env
# Server
SERVER_PORT=8080

# Database
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=prservice
DB_SSLMODE=disable
```

### 2. Запуск сервиса

```bash
make
```
`make` запускает `docker compose up`
Сервис будет доступен по адресу: http://localhost:8080

### 2. Проверка здоровья

```bash
curl http://localhost:8080/health
```

**Ожидаемый ответ:**
```json
{"status": "ok"}
```

## Бизнес-логика

### Автоматическое назначение ревьюеров
- Выбираются до 2 активных пользователей из команды автора
- Автор PR исключается из списка кандидатов
- Если доступных кандидатов меньше двух, назначается доступное количество (0/1)

### Переназначение ревьюверов
- Заменяемый ревьювер должен быть активным
- Новый ревьювер выбирается случайно из активных участников команды заменяемого
- Запрещено для MERGED PR

### Merge операция
- Идемпотентна - повторные вызовы безопасны
- Блокирует дальнейшие изменения списка ревьюверов
- Устанавливает статус PR в "MERGED"

## Тестирование

### Комплексное тестирование
```bash
# Полное тестирование всех эндпоинтов
bash ./scripts/test_all_endpoints.sh
# Полный цикл одного пулл реквеста
bash ./scripts/full_cycle_test.sh
```

### Ручное тестирование
Подробные примеры тестирования всех сценариев доступны в файле [testing.md](testing.md)



## Вопросы и принятые решения

1) Я решил сосредоточиться на хорошем выполнении основного задания вместо выполнения дополнительных заданий. Это позволило мне написать сервис согласно паттерну Clean Architecture и реализовать все слои в полной мере, с логгированием(количество выводимых логов можно менять в файле `pkg/logger/logger.go`) и покрытием тестами (их кстати можно запустить через `make test`, но работать оно будет около двух минут). Кроме того я реализовал Dependency Injection паттерн для вывода инициализации всех зависимостей в отдельном пакете, что сильно уменьшает main.(если у меня был бы ещё один день я бы реализовал и все допы)
2) Из допущений могу выделить только то, что не вывожу код в ответе сервера (например 200), так как не понял, принимает ли опенапи эти коды или нужны только сообщения, решил не рисковать, хотя в файле testing.md я их указал.
3) Я не писал конфигурацию линтера, но применял его в стандартном виде. В мейкфайле есть цель для проверки кода: `make lint`. Помимо этих двух линтеров у меня стоят настройки vscode, которые поддерживают автоформатирование согласно стандарту go.